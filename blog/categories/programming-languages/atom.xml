<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming languages | /home/andreas]]></title>
  <link href="http://aprell.github.io/blog/categories/programming-languages/atom.xml" rel="self"/>
  <link href="http://aprell.github.io/"/>
  <updated>2020-10-03T14:03:23+02:00</updated>
  <id>http://aprell.github.io/</id>
  <author>
    <name><![CDATA[Andreas Prell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Classic Programming Languages Papers]]></title>
    <link href="http://aprell.github.io/blog/2019/09/15/classic-programming-languages-papers/"/>
    <updated>2019-09-15T18:37:07+02:00</updated>
    <id>http://aprell.github.io/blog/2019/09/15/classic-programming-languages-papers</id>
    <content type="html"><![CDATA[<p>I found an old note reminding me that I wanted to compile a list of my
favorite papers in the area of programming languages. So, at long last, here
we go. Rather than trying to summarize each paper in a few (or more)
sentences, I take the easy way out and only drop a few keywords to highlight
important contributions or outstanding explanations.</p>

<!--more-->


<ul>
<li><p>Peter J. Landin, <a href="https://www.cs.cmu.edu/afs/cs/user/crary/www/819-f09/Landin64.pdf">The Mechanical Evaluation of Expressions</a>, 1964:
applicative expressions, syntactic sugar, evaluation, environment, abstract
machine (<a href="https://www.youtube.com/watch?v=QZzRritGiyI">Papers We Love presentation</a>)</p></li>
<li><p>Peter J. Landin, <a href="http://www.inf.ed.ac.uk/teaching/courses/epl/Landin66.pdf">The Next 700 Programming Languages</a>, 1966: ISWIM family
of programming languages, functional core, imperative features, equivalence
rules, declarative languages. (This paper ends with the transcript of an
interesting discussion that is still relevant today, over 50 years later.)</p></li>
<li><p>John C. Reynolds, <a href="http://surface.syr.edu/cgi/viewcontent.cgi?article=1012&amp;context=lcsmith_other">Definitional Interpreters for Higher-Order Programming
Languages</a>, 1972 / 1998: meta-circular interpreter, defunctionalization,
continuation-passing style (<a href="http://homepages.inf.ed.ac.uk/wadler/topics/history.html#definitional-interpreters">Papers We Love presentation</a>)</p></li>
<li><p>Paul Hudak, <a href="https://pdfs.semanticscholar.org/e694/49921581f1e00b801994236f840f5b459e00.pdf">The Conception, Evolution, and Application of Functional
Programming Languages</a>, 1989: history of functional programming
languages, including lambda calculus, Y combinator, order of evaluation,
call by value, call by name, and call by need (lazy evaluation)</p></li>
<li><p>Christopher Strachey, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.332.3161&amp;rep=rep1&amp;type=pdf">Fundamental Concepts in Programming Languages</a>,
2000: L-values and R-values, call by value, call by reference, first-class
objects, ad hoc polymorphism, parametric polymorphism (<a href="https://www.youtube.com/watch?v=cO41uoi5cZs">Papers We Love
presentation</a>)</p></li>
</ul>


<p>That&rsquo;s it for now. I hope to grow this list over time.</p>

<!--References-->



]]></content>
  </entry>
  
</feed>
